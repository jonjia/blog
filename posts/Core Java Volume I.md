#### 基础

- 强制类型转换：`double x = 9.997; int nx = (int) x;`
- 位运算(&、｜)和逻辑运算（&&、||）相比，不采用短路方式求值
- Java 中没有字符串类型，而是标准 Java 类库中提供了一预定义类，叫做 String。每个用双引号括起来的字符串都是 String 类型的一个实例
- 空串判断：`if (str.length() == 0)` 或 `if (str.equals(""))`
- Null 串判断：`if (str == null)`
- 不是 Null 串也不是空串：`if (str != null && str.length() != 0)`
- 格式化输出：`System.out.printf("%8.2f", x);`，打印 x 时**字段宽度**为 8，**精度**为 2 个字符。以 % 字符开头的是**格式说明符**
- 数组声明：`int a[]` 或者 `int[] a` (更常用)

#### 对象与类

- 类之间常见的关系：
  - 依赖（"use-a"） : Order 类依赖使用了 Account 类
  - 聚合（"has-a"）：一个 Order 对象包含一些 Item 对象
  - 继承（"is-a"）：特殊类与一般类之间的关系，比如 Manager 类继承了 Employee 类
- **文件名必须与 public 类的名字匹配，一个源文件中只能有一个公共类，但可以有任意多个非公共类**
- 构造器：
  - 构造器与类同名
  - 每个类可以有一个以上的构造器
  - 构造器可以有 0 个、1 个或多个参数
  - 构造器没有返回值
  - 构造器总是结合 new 操作符一起调用
- **静态字段属于类而不属于单个对象，每个静态字段只有一个副本**
- **静态常量，不需要每个对象都有一个常量**
- **静态方法，不是操作对象的方法，是没有 this 参数的方法**
- Java 语言**总是**采用**按值调用**
- 方法能对参数做什么和不能做什么：
  - 方法不能修改基本数据类型的参数（数值型和布尔型）
  - 方法可以改变对象参数的状态（引用型）
  - **方法不能让一个对象参数引用一个新对象**
- 构造对象：
  - 调用当前类中另一个构造器：`this(...)`
  - 初始化实例字段：
    - 在构造器中设置值 `this.name = namel;`
    - 在声明中赋值 `private static int nextId = 1;`
    - **初始化块**，初始化块总是放在字段定义后
- 类设计技巧：
  - 一定要保证数据私有：封装性，访问器（getter）、更改器 (setter)
  - **一定要初始化数据：显式初始化所有变量**
  - **不要在类中使用过多的基本类型**
  - 不是所有的字段都需要单独的字段访问器和更改器
  - 分解有过多职责的类
  - 类名和方法名要能够体现他们的职责。类型应当是名词、形容词修饰的名词、动名词修饰的名词
  - **优先使用不可变的类**，可以安全地在多个线程间共享对象

#### 继承

- super 只是一个指示编译器调用超类方法的特殊关键字
- `this(...)` 与 `super(...)`
- `this.method()` 与 `super.method()`
- **对象变量是多态的，一个 Employee 类型的变量既可以引用一个 Employee 类型的对象，又可以引用 Employee 类的任何一个子类的对象**
- 不允许扩展（定义子类）的类被称为 final 类，final 类中所有方法自动地成为 final 方法（不包括字段），枚举和记录总是 final，他们不允许扩展
- 强制类型转换：只能在继承层次结果内进行强制类型转换；将超类强制转换成子类之前，应该使用 instanceof 进行检查（因为超类实例不一定是子类实例）
- 4 个访问控制修饰符
  - 仅本类可以访问 - private
  - 本包中可以访问 - 默认，不需要修饰符
  - 本包和所有子类可以访问 - protected
  - 外部可以访问 - public
- getClass 方法返回一个对象所属的类
- 强烈建议为你自定义的每个类添加 toString 方法
- **ArrayList 是一个有类型参数的泛型类**，并不是语言设计的一部分，只是由某人编写并放在标准库中的一个实用工具类
- 对象包装器：自动装箱和自动拆箱是编译器要做的工作，而不是虚拟机
- **抽象类：包含一个或多个抽象方法的类本身必须被声明为抽象的，抽象方法相当于子类中具体实现方法的占位符。抽象类不能实例化**
- 枚举类：定义一个类，刚好有这几个枚举值作为实例
- 反射：能够分析类能力的程序称为可反射
- **Class 类实际上是一个泛型类**，Employee.class 的类型是 Class<Employee>
- 获取 Class 类对象的 3 种方法：`e.getClass()`、`Class.forName`、`int.class`
