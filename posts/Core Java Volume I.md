#### 基础

- 强制类型转换：`double x = 9.997; int nx = (int) x;`
- 位运算(&、｜)和逻辑运算（&&、||）相比，不采用短路方式求值
- Java 中没有字符串类型，而是标准 Java 类库中提供了一预定义类，叫做 String。每个用双引号括起来的字符串都是 String 类型的一个实例
- 空串判断：`if (str.length() == 0)` 或 `if (str.equals(""))`
- Null 串判断：`if (str == null)`
- 不是 Null 串也不是空串：`if (str != null && str.length() != 0)`
- 格式化输出：`System.out.printf("%8.2f", x);`，打印 x 时**字段宽度**为 8，**精度**为 2 个字符。以 % 字符开头的是**格式说明符**
- 数组声明：`int a[]` 或者 `int[] a` (更常用)

#### 对象与类

- 类之间常见的关系：
  - 依赖（"use-a"） : Order 类依赖使用了 Account 类
  - 聚合（"has-a"）：一个 Order 对象包含一些 Item 对象
  - 继承（"is-a"）：特殊类与一般类之间的关系，比如 Manager 类继承了 Employee 类
- **文件名必须与 public 类的名字匹配，一个源文件中只能有一个公共类，但可以有任意多个非公共类**
- 构造器：
  - 构造器与类同名
  - 每个类可以有一个以上的构造器
  - 构造器可以有 0 个、1 个或多个参数
  - 构造器没有返回值
  - 构造器总是结合 new 操作符一起调用
- **静态字段属于类而不属于单个对象，每个静态字段只有一个副本**
- **静态常量，不需要每个对象都有一个常量**
- **静态方法，不是操作对象的方法，是没有 this 参数的方法**
- **Java 语言总是采用按值调用**
- **方法能对参数做什么和不能做什么：**
  - 方法不能修改基本数据类型的参数（数值型和布尔型）
  - 方法可以改变对象参数的状态（引用型）
  - **方法不能让一个对象参数引用一个新对象**
- 构造对象：
  - 调用当前类中另一个构造器：`this(...)`
  - 初始化实例字段：
    - 在构造器中设置值 `this.name = namel;`
    - 在声明中赋值 `private static int nextId = 1;`
    - **初始化块**，初始化块总是放在字段定义后
- 类设计技巧：
  - 一定要保证数据私有：封装性，访问器（getter）、更改器 (setter)
  - **一定要初始化数据：显式初始化所有变量**
  - **不要在类中使用过多的基本类型**
  - 不是所有的字段都需要单独的字段访问器和更改器
  - 分解有过多职责的类
  - 类名和方法名要能够体现他们的职责。类型应当是名词、形容词修饰的名词、动名词修饰的名词
  - **优先使用不可变的类**，可以安全地在多个线程间共享对象

#### 继承

- super 只是一个指示编译器调用超类方法的特殊关键字
- `this(...)` 与 `super(...)`
- `this.method()` 与 `super.method()`
- **对象变量是多态的，一个 Employee 类型的变量既可以引用一个 Employee 类型的对象，又可以引用 Employee 类的任何一个子类的对象**
- 不允许扩展（定义子类）的类被称为 final 类，final 类中所有方法自动地成为 final 方法（不包括字段），枚举和记录总是 final，他们不允许扩展
- **强制类型转换：只能在继承层次结果内进行强制类型转换；将超类强制转换成子类之前，应该使用 instanceof 进行检查（因为超类实例不一定是子类实例）**
- **4 个访问控制修饰符**
  - 仅本类可以访问 - private
  - 本包中可以访问 - 默认，不需要修饰符
  - 本包和所有子类可以访问 - protected
  - 外部可以访问 - public
- getClass 方法返回一个对象所属的类
- 强烈建议为你自定义的每个类添加 toString 方法
- **ArrayList 是一个有类型参数的泛型类**，并不是语言设计的一部分，只是由某人编写并放在标准库中的一个实用工具类
- 对象包装器：自动装箱和自动拆箱是编译器要做的工作，而不是虚拟机
- **抽象类：包含一个或多个抽象方法的类本身必须被声明为抽象的，抽象方法相当于子类中具体实现方法的占位符。抽象类不能实例化**
- 枚举类：定义一个类，刚好有这几个枚举值作为实例
- 反射：能够分析类能力的程序称为可反射
- **Class 类实际上是一个泛型类**，Employee.class 的类型是 Class<Employee>
- **获取 Class 类对象的 3 种方法**：`e.getClass()`、`Class.forName`、`int.class`
- 如果一个方法包含一条可能抛出检查型异常的语句，则在方法名上增加一个 throws 子句
- java.lang.reflect 包中有三个类 Field、Method 和 Constructor
- 继承的设计技巧：
  - 将公共操作和公共字段放到超类中
  - 不要使用受保护的字段
  - 使用继承实现 is-a 关系
  - 覆盖方法时，不要改变预期的行为
  - **使用多态，而不要使用类型信息**
  - 不要滥用反射

#### 接口、lambda 表达式与内部类

- 接口不是类，是对希符合这个接口的类的一组需求
- 接口中的所有方法都自动是 public 方法，所有的字段都是 public static final
- 实现一个接口：1.将类声明为实现给定的接口 2.对接口中所有方法提供定义，实现接口时方法必须声明为 public
- `SomeInterface x; x = new SomeImplementClass();` 接口变量必须引用实现了这个接口的一个类对象
- **可以用 instanceof 检查一个对象是否属于某个特定类，也可以检查一个类是否实现了某个特定接口**
- **每个类只能有一个超类，但可以实现多个接口**
- **接口的默认方法，为语言演化提供便利，兼容之前的代码**
- **默认方法冲突：1. 类优先 2. 显示解决 `Person.super.getName();`**
- **接口与回调：回调参数是实现了约定接口的一个类对象**
- lambda 表达式是一个可以传递的代码块，以后可以执行一次或多次。可以看做是一个函数
- 对于只有一个抽象方法的接口，可以提供一个 lambda 表达式。这种接口称为函数式接口
- **用 :: 操作符分隔方法名与对象或类名的情况**
  - **object::instanceMethod **方法引用等价于一个 lambda 表达式，参数要传递到方法。`System.out::println` 等同于 `x -> System.out.println(x)`
  - **Class::instanceMethod **第一个参数会成为方法的隐式参数。`String::compareToIgnoreCase` 等同于 `(x, y) -> x.compareToIgnoreCase(y)`
  - **Class::staticMethod **所有参数都传递到静态方法。`Math::pow` 等同于 `(x, y) -> Math.pow(x, y)`
- lambda 表达式就是闭包，只能引用值不会改变的变量
- 内部类可以对同一包中的其他类隐藏
- 内部类方法可以访问定义这些方法的作用域中的数据
- 局部内部类、匿名内部类、静态内部类

#### 异常、断言和日志

- 异常处理就是将控制权从产生错误的地方转移到能够处理这种情况的一个错误处理器
- 错误分类：用户输入错误、设备错误（打印机关掉了）、物理限制（磁盘已满）、代码错误
- 异常对象都是派生于 Throwable 类的一个实例
- **Throwable 类分为 Error(内部错误很少出现) 和 Exception（RuntimeException、其他异常 IOException）**
- **继承自 RuntimeException 的问题：**
  - 错误的强制类型转换
  - 越界的数组访问
  - 访问 null 指针
- **不继承自 RuntimeException 的问题：**
  - 试图越过文件末尾继续读取数据
  - 试图打开一个不存在的文件
  - 试图查找一个不存在的类
- **派生于 Error 类或 RuntimeException 类的所有异常称为非检查型异常，其他异常称为检查型异常**
- **需要使用 throws 子句声明异常：**
  - 调用了一个抛出检查型异常的方法
  - 检测到一个错误，并使用 throw 语句抛出了一个检查型异常
  - 程序出现错误
  - 虚拟机或运行时库出现问题
- 一个方法必须声明**所有**可能抛出的**检查型异常**
- 常见异常类，定义一个派生于 Exception 或 Exception 某个子类的类
- **捕获那些你知道如何处理的异常，继续传播那些你不知道怎么处理的异常**
- **catch 子句中可以抛出一个异常，通常在希望改变异常类型时会这么做**
- 使用 `initCause()、getCause()` 包装异常
- 需要在正常代码和异常代码中清理资源，finally 子句可以解决这个问题
- **finally 子句的返回值会遮蔽原来的返回值，不要把改变控制流的语句放到 finally 子句中**
- 使用异常的技巧：1.寻找合适的异常类或自己创建 2.不要吞掉异常 3. 苛刻比放任好
- **弹栈前要检查是否为空**
- 使用断言：确性满足某个特定属性，并且代码依赖这个特定属性
- **断言是用于测试和调试的战术性工具，日志是用于程序整个生命周期的战略性工具**
- INFO、WARNING、SEVERE 级别的日志显示在控制台，程序员想要的日志信息用 FINE 级别就行

#### 泛型程序设计

- 泛型类和泛型方法有类型参数，**可以准确地描述用特定类型实例化时会发生什么**
- 泛型类就是有一个或多个类型变量的类
- **泛型类相当于普通类的工厂**
- 泛型方法：类型变量放在修饰符后面，返回类型前面
- 调用一个泛型方法：可以把具体的类型包围在尖括号中，放在方法名前
- **类型变量的限定：T 是限定类型的子类型，T 和限定类型可以是类，也可以是接口**
- 可以有多个接口限定类型，但最多有一个限定可以是类，并且这个类限定需要放在限定列表的第一位
- 虚拟机中没有泛型，只有普通的类和方法
- 所有的类型参数都会替换为他们的限定类型
- 会合成桥方法保持多态
- 为保持类型安全，必要时会插入强制类型转换
- 运行时类型查询只适用于类型擦除后的原始类型
- 无论 S 与 T 有什么关系， `Pair<S>` 与 `Pair<T>` 都没有任何关系
- 通配符类型：`Pair<? extends Employee>`，`Pair<? super Manager>`，`Pair<?>`

#### 集合

- Java 类库将接口与实现分离，**集合类的基本接口是 Collection 和 Map 接口**
- **集合是 Collection，集是 Set，映射是 Map**
- **Collection、Map 和 Iterator 都是泛型接口**
- **AbstractCollection、AbstractMap 超类实现了大部分方法，具体集合类可以扩展这个超类**
- **ListIterator 是 Iterator 的一个子接口，定义了一个 add 方法用于在迭代器前面增加一个元素**
- 循环数组队列可以用 ArrayQueue 类，链表队列可以用 LinkedList 类
- 一旦构造了集合，不需要知道使用了哪种实现，可以修改构造器部分轻松改为另一种实现
- 循环数组是一个有界集合，他的容量有限；如果要收集的对象数量没有上限，可以使用链表
- 使用迭代器：1. hasNext + next 2. for each 循环 3. forEachRemaining
- C++ 不需要查找元素也可以移动迭代器位置
- **Java 迭代器查找操作与位置变换紧密耦合**
- **Iterator.next 等同于 InputStream.read，从数据流中读取一个字节就会自动地消耗掉这个字节**
- **Iterator.remove 方法会删除上次调用 next 方法返回的元素（因为读取和位置紧密关联）**
- **next 方法和 remove 方法中间存在依赖性，调用 remove 之前需要调用 next**
- **随机访问：使用一个整型索引来访问**
- **顺序访问：使用一个迭代器来访问**
- **add 方法只依赖迭代器的位置，而 remove 方法还要依赖迭代器的状态**
- **一个集合可以同时关联多个读迭代器或一个读写迭代器**
- LinkedList：Java 中所有链表都有双向链接
- ArrayList：有序集合中元素位置很重要，有 2 种访问方式：通过迭代器、通过 get 和 set 方法随机访问
- ArrayList：单线程使用 ArrayList，多线程使用 Vector (他的方法都是同步的，线程安全)
- **Java 中散列表的实现是链表数组**
- 标准库桶数为 2 的幂，装填因子为 0.75 是合理的
- TreeSet：需要数据有序，任意两个元素是可以比较的
- 双端队列：可以在队头或队尾添加/删除元素
- **优先队列：任意顺序插入，有序的顺序读取。应用场景是任务调度，可以按优先级调度任务**
- 更新映射条目：1. getOrDefault 2. putIfAbsent 3. merge
- **映射的视图：实现了 Collection 接口或其某个子接口的对象**
- **有 3 种视图**：
  1. 键集 `Set<K> keySet()`
  2. 值集合 `Collection<V> values()`
  3. 键/值对集 `Set<Map.Entry<K, V>> entrySet`
- 枚举集 EnumSet 的元素属于一个枚举类型
- 枚举映射 EnumMap 的键属于一个枚举类型
- **原集合修改，副本不受影响，视图会反应这些变化**
- 子范围：subList 等方法获取子范围视图
- 检查型视图：`Collections.checkedList(string,  String.class)` 可以检查插入的对象是否属于给定的类
- 同步视图：`Collections.synchronizedMap`
- 算法：
  - sort 和 shuffle，稳定排序
  - search: binarySearch 要求集合有序，并可以随机访问
  - 简单算法：max、min、批操作（replaceAll、removeAll、retainAll），并集：firstSet.retainAll(secondSet)
- 集合与数组的转换
  - 数组转成 List：List.of()
  - 集合转数组：List.toArray()
- 属性映射：键和值都是字符串
- 有序：LinkedList、ArrayList/Vector、TreeSet、TreeMap、EnumSet、EnumMap
- 无序： HashTable/HashSet、HashMap
