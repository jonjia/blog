#### 基础

- 强制类型转换：`double x = 9.997; int nx = (int) x;`
- 位运算(&、｜)和逻辑运算（&&、||）相比，不采用短路方式求值
- Java 中没有字符串类型，而是标准 Java 类库中提供了一预定义类，叫做 String。每个用双引号括起来的字符串都是 String 类型的一个实例
- 空串判断：`if (str.length() == 0)` 或 `if (str.equals(""))`
- Null 串判断：`if (str == null)`
- 不是 Null 串也不是空串：`if (str != null && str.length() != 0)`
- 格式化输出：`System.out.printf("%8.2f", x);`，打印 x 时**字段宽度**为 8，**精度**为 2 个字符。以 % 字符开头的是**格式说明符**
- 数组声明：`int a[]` 或者 `int[] a` (更常用)

#### 对象与类

- 类之间常见的关系：
  - 依赖（"use-a"） : Order 类依赖使用了 Account 类
  - 聚合（"has-a"）：一个 Order 对象包含一些 Item 对象
  - 继承（"is-a"）：特殊类与一般类之间的关系，比如 Manager 类继承了 Employee 类
- **文件名必须与 public 类的名字匹配，一个源文件中只能有一个公共类，但可以有任意多个非公共类**
- 构造器：
  - 构造器与类同名
  - 每个类可以有一个以上的构造器
  - 构造器可以有 0 个、1 个或多个参数
  - 构造器没有返回值
  - 构造器总是结合 new 操作符一起调用
- **静态字段属于类而不属于单个对象，每个静态字段只有一个副本**
- **静态常量，不需要每个对象都有一个常量**
- **静态方法，不是操作对象的方法，是没有 this 参数的方法**
- Java 语言**总是**采用**按值调用**
- 方法能对参数做什么和不能做什么：
  - 方法不能修改基本数据类型的参数（数值型和布尔型）
  - 方法可以改变对象参数的状态（引用型）
  - **方法不能让一个对象参数引用一个新对象**
- 构造对象：
  - 调用当前类中另一个构造器：`this(...)`
  - 初始化实例字段：
    - 在构造器中设置值 `this.name = namel;`
    - 在声明中赋值 `private static int nextId = 1;`
    - **初始化块**，初始化块总是放在字段定义后
- 类设计技巧：
  - 一定要保证数据私有：封装性，访问器（getter）、更改器 (setter)
  - **一定要初始化数据：显式初始化所有变量**
  - **不要在类中使用过多的基本类型**
  - 不是所有的字段都需要单独的字段访问器和更改器
  - 分解有过多职责的类
  - 类名和方法名要能够体现他们的职责。类型应当是名词、形容词修饰的名词、动名词修饰的名词
  - **优先使用不可变的类**，可以安全地在多个线程间共享对象

#### 继承

- super 只是一个指示编译器调用超类方法的特殊关键字
- `this(...)` 与 `super(...)`
- `this.method()` 与 `super.method()`
- **对象变量是多态的，一个 Employee 类型的变量既可以引用一个 Employee 类型的对象，又可以引用 Employee 类的任何一个子类的对象**
- 不允许扩展（定义子类）的类被称为 final 类，final 类中所有方法自动地成为 final 方法（不包括字段），枚举和记录总是 final，他们不允许扩展
- 强制类型转换：只能在继承层次结果内进行强制类型转换；将超类强制转换成子类之前，应该使用 instanceof 进行检查（因为超类实例不一定是子类实例）
- 4 个访问控制修饰符
  - 仅本类可以访问 - private
  - 本包中可以访问 - 默认，不需要修饰符
  - 本包和所有子类可以访问 - protected
  - 外部可以访问 - public
- getClass 方法返回一个对象所属的类
- 强烈建议为你自定义的每个类添加 toString 方法
- **ArrayList 是一个有类型参数的泛型类**，并不是语言设计的一部分，只是由某人编写并放在标准库中的一个实用工具类
- 对象包装器：自动装箱和自动拆箱是编译器要做的工作，而不是虚拟机
- **抽象类：包含一个或多个抽象方法的类本身必须被声明为抽象的，抽象方法相当于子类中具体实现方法的占位符。抽象类不能实例化**
- 枚举类：定义一个类，刚好有这几个枚举值作为实例
- 反射：能够分析类能力的程序称为可反射
- **Class 类实际上是一个泛型类**，Employee.class 的类型是 Class<Employee>
- 获取 Class 类对象的 3 种方法：`e.getClass()`、`Class.forName`、`int.class`
- 如果一个方法包含一条可能抛出检查型异常的语句，则在方法名上增加一个 throws 子句
- java.lang.reflect 包中有三个类 Field、Method 和 Constructor
- 继承的设计技巧：
  - 将公共操作和公共字段放到超类中
  - 不要使用受保护的字段
  - 使用继承实现 is-a 关系
  - 覆盖方法时，不要改变预期的行为
  - **使用多态，而不要使用类型信息**
  - 不要滥用反射

#### 接口、lambda 表达式与内部类

- 接口不是类，是对希符合这个接口的类的一组需求
- 接口中的所有方法都自动是 public 方法，所有的字段都是 public static final
- 实现一个接口：1.将类声明为实现给定的接口 2.对接口中所有方法提供定义，实现接口时方法必须声明为 public
- `SomeInterface x; x = new SomeImplementClass();` 接口变量必须引用实现了这个接口的一个类对象
- 可以用 instanceof 检查一个对象是否属于某个特定类，也可以检查一个类是否实现了某个特定接口
- 每个类只能有一个超类，但可以实现多个接口
- 接口的默认方法，为语言演化提供便利，兼容之前的代码
- 默认方法冲突：1. 类优先 2. 显示解决 `Person.super.getName();`
- 接口与回调：回调参数是实现了约定接口的一个类对象
- lambda 表达式是一个可以传递的代码块，以后可以执行一次或多次。可以看做是一个函数
- 对于只有一个抽象方法的接口，可以提供一个 lambda 表达式。这种接口称为函数式接口
- 用 :: 操作符分隔方法名与对象或类名的情况
  - object::instanceMethod 方法引用等价于一个 lambda 表达式，参数要传递到方法。`System.out::println` 等同于 `x -> System.out.println(x)`
  - Class::instanceMethod 第一个参数会成为方法的隐式参数。`String::compareToIgnoreCase` 等同于 `(x, y) -> x.compareToIgnoreCase(y)`
  - Class::staticMethod 所有参数都传递到静态方法。`Math::pow` 等同于 `(x, y) -> Math.pow(x, y)`
- lambda 表达式就是闭包，只能引用值不会改变的变量
- 内部类可以对同一包中的其他类隐藏
- 内部类方法可以访问定义这些方法的作用域中的数据
- 局部内部类、匿名内部类、静态内部类

#### 泛型程序设计

- 泛型类和泛型方法有类型参数，**可以准确地描述用特定类型实例化时会发生什么**
- 泛型类就是有一个或多个类型变量的类
- **泛型类相当于普通类的工厂**
- 泛型方法：类型变量放在修饰符后面，返回类型前面
- 调用一个泛型方法：可以把具体的类型包围在尖括号中，放在方法名前
- **类型变量的限定：T 是限定类型的子类型，T 和限定类型可以是类，也可以是接口**
- 可以有多个接口限定类型，但最多有一个限定可以是类，并且这个类限定需要放在限定列表的第一位
